{
  "hash": "184aa7c14e61757d7843a3a8c86ee0c3",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 7 - Analytical Mapping\"\ndate: \"3 February 2024\"\ndate-modified: \"last-modified\"\nformat: html\nexecute: \n  echo: true # all code chunks will appear\n  eval: true # all code chunks will run live\n  warning: false # do not display warning message\n  freeze: true # do not render if no changes made\n  message: false\neditor: visual\n---\n\n\n# 1. Overview\n\nIn the third part of the seventh lesson, we learn to create analytical maps using the [`tmap`](https://cran.r-project.org/web/packages/tmap/) package.\n\n# 2. Getting Started\n\n## 2.1. Installing and Loading Packages\n\nWe will use the following R packages in addition to `tidyverse` for this exercise:\n\n1.  [`tmap`](https://cran.r-project.org/web/packages/tmap/): to create choropleth maps\n\n2.  [`sf`](https://cran.r-project.org/web/packages/sf/): to handle geospatial data\n\nThe packages to be used can be installed and loaded into the R environment using the `p_load()` function from the `pacman` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, tmap, sf)\n```\n:::\n\n\n## 2.2. The Data\n\nWe will use a dataset called NGA_wp.rds prepared by the Course Instructor. The dataset is a polygon feature dataframe that provides information on water points in Nigeria at the Local Government level. \n\n### 2.2.1. Import Data\n\nWe will read the asaptial data into the R environment using the `read_csv()` function from the `readrds` package found in `tidyverse`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga_wp <- read_rds(\"data/rds/NGA_wp.rds\")\nlist(nga_wp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nSimple feature collection with 774 features and 8 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 26662.71 ymin: 30523.38 xmax: 1344157 ymax: 1096029\nProjected CRS: Minna / Nigeria Mid Belt\nFirst 10 features:\n          ADM2_EN ADM2_PCODE                   ADM1_EN ADM1_PCODE\n1       Aba North   NG001001                      Abia      NG001\n2       Aba South   NG001002                      Abia      NG001\n3          Abadam   NG008001                     Borno      NG008\n4           Abaji   NG015001 Federal Capital Territory      NG015\n5            Abak   NG003001                 Akwa Ibom      NG003\n6       Abakaliki   NG011001                    Ebonyi      NG011\n7  Abeokuta North   NG028001                      Ogun      NG028\n8  Abeokuta South   NG028002                      Ogun      NG028\n9             Abi   NG009001               Cross River      NG009\n10    Aboh-Mbaise   NG017001                       Imo      NG017\n                         geometry total_wp wp_functional wp_nonfunctional\n1  MULTIPOLYGON (((548795.5 11...       17             7                9\n2  MULTIPOLYGON (((547286.1 11...       71            29               35\n3  MULTIPOLYGON (((1248985 104...        0             0                0\n4  MULTIPOLYGON (((510864.9 57...       57            23               34\n5  MULTIPOLYGON (((594269 1209...       48            23               25\n6  MULTIPOLYGON (((660767 2522...      233            82               42\n7  MULTIPOLYGON (((78621.56 37...       34            16               15\n8  MULTIPOLYGON (((106627.7 35...      119            72               33\n9  MULTIPOLYGON (((632244.2 21...      152            79               62\n10 MULTIPOLYGON (((540081.3 15...       66            18               26\n   wp_unknown\n1           1\n2           7\n3           0\n4           0\n5           0\n6         109\n7           3\n8          14\n9          11\n10         22\n```\n:::\n:::\n\n\nWe can observe from above that the sf dataframe contains 774 records with 8 features.\n\n# 3. Basic Choropleth Mapping\n\n::: panel-tabset\n#### Functional Water Points\n\nFirst, we plot a choropleth map showing the distribution of functional water points by local government area:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunc_wp <- tm_shape(nga_wp) +\n  tm_fill(\"wp_functional\",\n          n = 10,\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders(lwd = 0.05,\n             col = \"grey40\") +\n  tm_layout(main.title = \"Distribution of Functional Water Points by LGAs\",\n            main.title.size = 0.7)\n\ntotal_wp <- tm_shape(nga_wp) +\n  tm_fill(\"total_wp\",\n          n = 10,\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders(lwd = 0.05,\n             col = \"grey40\") +\n  tm_layout(main.title = \"Distribution of Total Water Points by LGAs\",\n            main.title.size = 0.7) \n\ntmap_arrange(total_wp, func_wp)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n#### Non-Functional Water Points\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnonfunc_wp <- tm_shape(nga_wp) +\n  tm_fill(\"wp_nonfunctional\",\n          n = 10,\n          style = \"pretty\",\n          palette = \"Reds\") +\n  tm_borders(lwd = 0.05,\n             col = \"grey40\") +\n  tm_layout(main.title = \"Distribution of Functional Water Points by LGAs\",\n            main.title.size = 0.7)\n\ntotal_wp <- tm_shape(nga_wp) +\n  tm_fill(\"total_wp\",\n          n = 10,\n          style = \"pretty\",\n          palette = \"Blues\") +\n  tm_borders(lwd = 0.05,\n             col = \"grey40\") +\n  tm_layout(main.title = \"Distribution of Total Water Points by LGAs\",\n            main.title.size = 0.7) \n\ntmap_arrange(total_wp, nonfunc_wp)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::::\n\n# 4. Choropleth Map for Rates\n\nWhen plotting total count of a variable on a map, it does not take into account that the variable may not be equally distributed in space. Hence, we have to derive proportions (or rates) of the appearance of the variables.\n\n## 4.1. Deriving Proportion of Functional and Non-Functional Water Points\n\nFirst, we create additional columns in the dataframe to hold the derived percentage values. We can achieve this using the `mutate` function from the `dplyr` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga_wp <- nga_wp %>%\n  mutate(pct_func = wp_functional/total_wp) %>%\n  mutate(pct_nonfunc = wp_nonfunctional/total_wp)\n```\n:::\n\n\n## 4.2. Plotting Map for Rates\n\n::: panel-tabset\n\n#### Functional Water Points\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(nga_wp) +\n  tm_fill(\"pct_func\",\n          n = 10,\n          style = \"pretty\",\n          palette = \"Blues\",\n          legend.hist = TRUE) +\n  tm_borders(lwd = 0.05,\n             col = \"grey40\") +\n  tm_layout(main.title = \"Distribution of Percentage of Functional Water Points by LGAs\",\n            main.title.size = 0.7,\n            legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n#### Non-Functional Water Points\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(nga_wp) +\n  tm_fill(\"pct_nonfunc\",\n          n = 10,\n          style = \"pretty\",\n          palette = \"Reds\",\n          legend.hist = TRUE) +\n  tm_borders(lwd = 0.05,\n             col = \"grey40\") +\n  tm_layout(main.title = \"Distribution of Percentage of Non-Functional Water Points by LGAs\",\n            main.title.size = 0.7,\n            legend.outside = TRUE)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n:::\n\n# 5. Extreme Value Maps\n\nExtreme value maps highlight the extreme values at the lower and upper end of the scale to identify outliers. \n\n## 5.1. Perentile Maps\n\nWe can create percentile maps showing customised percentile categories. These categories, and it corresponding breakpoints can be determined using the base R `quantile` function. \n\n### 5.1.1. Data Preparation\n\nFirst, we exclude records with NA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnga_wp <- nga_wp %>%\n  drop_na()\n```\n:::\n\n\nNext, we create customised classifications:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercent <- c(0, 0.01, 0.1, 0.5, 0.9, 0.99, 1)\nvar <- nga_wp[\"pct_func\"] %>%\n  st_set_geometry(NULL)\nquantile(var[,1], percent)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       0%        1%       10%       50%       90%       99%      100% \n0.0000000 0.0000000 0.2169811 0.4791667 0.8611111 1.0000000 1.0000000 \n```\n:::\n:::\n\n\n\n::: callout-note\n-   `st_set_geometry(NULL)` is used to drop the geometry field. Otherwise, the geometry field would be extracted together with the intended variables. \n\n### 5.1.2. Creating `get.var` Function\n\nWe will next create our own function labelled as `get.var`to extract a variable as a vector from the sf dataframe. The function takes in two arguments - variable name, `vname`, and the source dataframe, `df` - and will return a vector with values `v`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget.var <- function(vname,df) {\n  v <- df[vname] %>% \n    st_set_geometry(NULL)\n  v <- unname(v[,1])\n  return(v)\n}\n```\n:::\n\n\n### 5.1.3. Percentile Mapping Function\n\nNext, we write a percentile mapping function that includes the `get.var` function previously created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercentmap <- function(vnam, df, legtitle=NA, mtitle=\"Percentile Map\") {\n  percent <- c(0,.01,.1,.5,.9,.99,1)\n  var <- get.var(vnam, df)\n  bperc <- quantile(var, percent)\n  tm_shape(df) +\n    tm_polygons() +\n    tm_shape(df) +\n    tm_fill(vnam,\n            title=legtitle,\n            breaks=bperc,\n            palette=\"Blues\",\n            labels=c(\"< 1%\", \"1% - 10%\", \"10% - 50%\", \"50% - 90%\", \"90% - 99%\", \"> 99%\")) +  \n    tm_borders() +\n    tm_layout(main.title = mtitle, \n              main.title.size = 0.7,\n              title.position = c(\"right\",\"bottom\"))\n}\n```\n:::\n\n\n### 5.1.4. Testing the Function\n\n\n::: {.cell}\n\n```{.r .cell-code}\npercentmap(\"total_wp\", nga_wp)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n## 5.2. Box Maps\n\nA box map is an augmented quartile map, with an additional lower and upper category. \n\nWhen lower outliers are present, the first breakpoint is the minimum value, the second breakpoint is at the lower fence.\n\nWhen lower outliers are absent, the first breakpoint is at the lower fence, and the second breakpoint is at the minimum value.\n\nFirst, we plot a boxplot to understand the distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = nga_wp,\n       aes(x = \"\",\n           y = wp_nonfunctional)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n### 5.2.1. Create `boxbreaks` Function\n\nWe will create our own function labelled as `boxbreaks`to create breakpoints for a box map. The function takes in two arguments - vector, `v`, and a multiplier for IQR, `mult` - and will return a vector 7 box break points `bb`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxbreaks <- function(v, mult = 1.5) {\n  qv <- unname(quantile(v))\n  iqr <- qv[4] - qv[2]\n  upfence <- qv[4] + mult * iqr\n  lofence <- qv[2] - mult * iqr\n  # initialize break points vector\n  bb <- vector(mode=\"numeric\",length=7)\n  # logic for lower and upper fences\n  if (lofence < qv[1]) {  # no lower outliers\n    bb[1] <- lofence\n    bb[2] <- floor(qv[1])\n  } else {\n    bb[2] <- lofence\n    bb[1] <- qv[1]\n  }\n  if (upfence > qv[5]) { # no upper outliers\n    bb[7] <- upfence\n    bb[6] <- ceiling(qv[5])\n  } else {\n    bb[6] <- upfence\n    bb[7] <- qv[5]\n  }\n  bb[3:5] <- qv[2:4]\n  return(bb)\n}\n```\n:::\n\n\n### 5.2.2. Create `get.var` Function\n\nWe will next create our own function labelled as `get.var`to extract a variable as a vector from the sf dataframe. The function takes in two arguments - variable name, `vname`, and the source dataframe, `df` - and will return a vector with values `v`. \n\nThe output of the `get.var` function will be fed into the `boxbreaks` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget.var <- function(vname,df) {\n  v <- df[vname] %>% \n    st_set_geometry(NULL)\n  v <- unname(v[,1])\n  return(v)\n}\n```\n:::\n\n\n### 5.2.3. Testing the Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar <- get.var(\"wp_nonfunctional\", nga_wp) \nboxbreaks(var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -56.5   0.0  14.0  34.0  61.0 131.5 278.0\n```\n:::\n:::\n\n\n### 5.2.4. Creating `boxmap` Function\n\nLastly, we create a `boxmap` function to create a tmap element with the output of the `get.var` and `boxbreaks` functions. This function takes in arguments - variable name, `vname`, source data frame, `df`, legend title, `legtitle`, map title, `mtitle`, and a multiplier for IQR, `mult`. The function returns a tmap element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxmap <- function(vnam, df, \n                   legtitle=NA,\n                   mtitle=\"Box Map\",\n                   mult=1.5){\n  var <- get.var(vnam,df)\n  bb <- boxbreaks(var)\n  tm_shape(df) +\n    tm_polygons() +\n    tm_shape(df) +\n    tm_fill(vnam,title=legtitle,\n            breaks=bb,\n            palette=\"Blues\",\n            labels = c(\"lower outlier\", \n                       \"< 25%\", \n                       \"25% - 50%\", \n                       \"50% - 75%\",\n                       \"> 75%\", \n                       \"upper outlier\")) +\n    tm_borders() +\n    tm_layout(main.title = mtitle, \n              title.position = c(\"left\", \"top\"))\n}\n```\n:::\n\n\n### 5.2.5. Plotting Box Map\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nboxmap(\"wp_nonfunctional\", nga_wp)\n```\n\n::: {.cell-output-display}\n![](hands_on_ex07_3_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "hands_on_ex07_3_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}